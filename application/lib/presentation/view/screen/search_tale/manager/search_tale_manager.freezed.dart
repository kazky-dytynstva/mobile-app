// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'search_tale_manager.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SearchTaleState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(
            List<TalesPageItemData> results,
            TaleName taleName,
            PersonName authorName,
            Option<StringSingleLine> searchPhraseOption)
        ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<TalesPageItemData> results, TaleName taleName,
            PersonName authorName, Option<StringSingleLine> searchPhraseOption)?
        ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<TalesPageItemData> results, TaleName taleName,
            PersonName authorName, Option<StringSingleLine> searchPhraseOption)?
        ready,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(SearchTaleStateReady value) ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(SearchTaleStateReady value)? ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(SearchTaleStateReady value)? ready,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchTaleStateCopyWith<$Res> {
  factory $SearchTaleStateCopyWith(
          SearchTaleState value, $Res Function(SearchTaleState) then) =
      _$SearchTaleStateCopyWithImpl<$Res, SearchTaleState>;
}

/// @nodoc
class _$SearchTaleStateCopyWithImpl<$Res, $Val extends SearchTaleState>
    implements $SearchTaleStateCopyWith<$Res> {
  _$SearchTaleStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitCopyWith<$Res> {
  factory _$$_InitCopyWith(_$_Init value, $Res Function(_$_Init) then) =
      __$$_InitCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitCopyWithImpl<$Res>
    extends _$SearchTaleStateCopyWithImpl<$Res, _$_Init>
    implements _$$_InitCopyWith<$Res> {
  __$$_InitCopyWithImpl(_$_Init _value, $Res Function(_$_Init) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Init implements _Init {
  const _$_Init();

  @override
  String toString() {
    return 'SearchTaleState.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Init);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(
            List<TalesPageItemData> results,
            TaleName taleName,
            PersonName authorName,
            Option<StringSingleLine> searchPhraseOption)
        ready,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<TalesPageItemData> results, TaleName taleName,
            PersonName authorName, Option<StringSingleLine> searchPhraseOption)?
        ready,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<TalesPageItemData> results, TaleName taleName,
            PersonName authorName, Option<StringSingleLine> searchPhraseOption)?
        ready,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(SearchTaleStateReady value) ready,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(SearchTaleStateReady value)? ready,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(SearchTaleStateReady value)? ready,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements SearchTaleState {
  const factory _Init() = _$_Init;
}

/// @nodoc
abstract class _$$SearchTaleStateReadyCopyWith<$Res> {
  factory _$$SearchTaleStateReadyCopyWith(_$SearchTaleStateReady value,
          $Res Function(_$SearchTaleStateReady) then) =
      __$$SearchTaleStateReadyCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<TalesPageItemData> results,
      TaleName taleName,
      PersonName authorName,
      Option<StringSingleLine> searchPhraseOption});
}

/// @nodoc
class __$$SearchTaleStateReadyCopyWithImpl<$Res>
    extends _$SearchTaleStateCopyWithImpl<$Res, _$SearchTaleStateReady>
    implements _$$SearchTaleStateReadyCopyWith<$Res> {
  __$$SearchTaleStateReadyCopyWithImpl(_$SearchTaleStateReady _value,
      $Res Function(_$SearchTaleStateReady) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? results = null,
    Object? taleName = null,
    Object? authorName = null,
    Object? searchPhraseOption = null,
  }) {
    return _then(_$SearchTaleStateReady(
      results: null == results
          ? _value._results
          : results // ignore: cast_nullable_to_non_nullable
              as List<TalesPageItemData>,
      taleName: null == taleName
          ? _value.taleName
          : taleName // ignore: cast_nullable_to_non_nullable
              as TaleName,
      authorName: null == authorName
          ? _value.authorName
          : authorName // ignore: cast_nullable_to_non_nullable
              as PersonName,
      searchPhraseOption: null == searchPhraseOption
          ? _value.searchPhraseOption
          : searchPhraseOption // ignore: cast_nullable_to_non_nullable
              as Option<StringSingleLine>,
    ));
  }
}

/// @nodoc

class _$SearchTaleStateReady implements SearchTaleStateReady {
  const _$SearchTaleStateReady(
      {required final List<TalesPageItemData> results,
      required this.taleName,
      required this.authorName,
      required this.searchPhraseOption})
      : _results = results;

  final List<TalesPageItemData> _results;
  @override
  List<TalesPageItemData> get results {
    if (_results is EqualUnmodifiableListView) return _results;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_results);
  }

  @override
  final TaleName taleName;
  @override
  final PersonName authorName;
  @override
  final Option<StringSingleLine> searchPhraseOption;

  @override
  String toString() {
    return 'SearchTaleState.ready(results: $results, taleName: $taleName, authorName: $authorName, searchPhraseOption: $searchPhraseOption)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchTaleStateReady &&
            const DeepCollectionEquality().equals(other._results, _results) &&
            (identical(other.taleName, taleName) ||
                other.taleName == taleName) &&
            (identical(other.authorName, authorName) ||
                other.authorName == authorName) &&
            (identical(other.searchPhraseOption, searchPhraseOption) ||
                other.searchPhraseOption == searchPhraseOption));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_results),
      taleName,
      authorName,
      searchPhraseOption);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchTaleStateReadyCopyWith<_$SearchTaleStateReady> get copyWith =>
      __$$SearchTaleStateReadyCopyWithImpl<_$SearchTaleStateReady>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(
            List<TalesPageItemData> results,
            TaleName taleName,
            PersonName authorName,
            Option<StringSingleLine> searchPhraseOption)
        ready,
  }) {
    return ready(results, taleName, authorName, searchPhraseOption);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(List<TalesPageItemData> results, TaleName taleName,
            PersonName authorName, Option<StringSingleLine> searchPhraseOption)?
        ready,
  }) {
    return ready?.call(results, taleName, authorName, searchPhraseOption);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(List<TalesPageItemData> results, TaleName taleName,
            PersonName authorName, Option<StringSingleLine> searchPhraseOption)?
        ready,
    required TResult orElse(),
  }) {
    if (ready != null) {
      return ready(results, taleName, authorName, searchPhraseOption);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(SearchTaleStateReady value) ready,
  }) {
    return ready(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(SearchTaleStateReady value)? ready,
  }) {
    return ready?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(SearchTaleStateReady value)? ready,
    required TResult orElse(),
  }) {
    if (ready != null) {
      return ready(this);
    }
    return orElse();
  }
}

abstract class SearchTaleStateReady implements SearchTaleState {
  const factory SearchTaleStateReady(
          {required final List<TalesPageItemData> results,
          required final TaleName taleName,
          required final PersonName authorName,
          required final Option<StringSingleLine> searchPhraseOption}) =
      _$SearchTaleStateReady;

  List<TalesPageItemData> get results;
  TaleName get taleName;
  PersonName get authorName;
  Option<StringSingleLine> get searchPhraseOption;
  @JsonKey(ignore: true)
  _$$SearchTaleStateReadyCopyWith<_$SearchTaleStateReady> get copyWith =>
      throw _privateConstructorUsedError;
}
