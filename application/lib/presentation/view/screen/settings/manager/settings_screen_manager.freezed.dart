// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'settings_screen_manager.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SettingsScreenState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)
        ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)?
        ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)?
        ready,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SettingsScreenStateReady value) ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SettingsScreenStateReady value)? ready,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SettingsScreenStateReady value)? ready,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SettingsScreenStateCopyWith<$Res> {
  factory $SettingsScreenStateCopyWith(
          SettingsScreenState value, $Res Function(SettingsScreenState) then) =
      _$SettingsScreenStateCopyWithImpl<$Res, SettingsScreenState>;
}

/// @nodoc
class _$SettingsScreenStateCopyWithImpl<$Res, $Val extends SettingsScreenState>
    implements $SettingsScreenStateCopyWith<$Res> {
  _$SettingsScreenStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_InitialCopyWith<$Res> {
  factory _$$_InitialCopyWith(
          _$_Initial value, $Res Function(_$_Initial) then) =
      __$$_InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitialCopyWithImpl<$Res>
    extends _$SettingsScreenStateCopyWithImpl<$Res, _$_Initial>
    implements _$$_InitialCopyWith<$Res> {
  __$$_InitialCopyWithImpl(_$_Initial _value, $Res Function(_$_Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'SettingsScreenState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)
        ready,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)?
        ready,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)?
        ready,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SettingsScreenStateReady value) ready,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SettingsScreenStateReady value)? ready,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SettingsScreenStateReady value)? ready,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SettingsScreenState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$$SettingsScreenStateReadyCopyWith<$Res> {
  factory _$$SettingsScreenStateReadyCopyWith(_$SettingsScreenStateReady value,
          $Res Function(_$SettingsScreenStateReady) then) =
      __$$SettingsScreenStateReadyCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<SettingsPageType> pages,
      int initialPageIndex,
      SettingsDataGeneral dataGeneral,
      SettingsDataText dataText,
      SettingsDataAudio dataAudio});

  $SettingsDataGeneralCopyWith<$Res> get dataGeneral;
  $SettingsDataTextCopyWith<$Res> get dataText;
  $SettingsDataAudioCopyWith<$Res> get dataAudio;
}

/// @nodoc
class __$$SettingsScreenStateReadyCopyWithImpl<$Res>
    extends _$SettingsScreenStateCopyWithImpl<$Res, _$SettingsScreenStateReady>
    implements _$$SettingsScreenStateReadyCopyWith<$Res> {
  __$$SettingsScreenStateReadyCopyWithImpl(_$SettingsScreenStateReady _value,
      $Res Function(_$SettingsScreenStateReady) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pages = null,
    Object? initialPageIndex = null,
    Object? dataGeneral = null,
    Object? dataText = null,
    Object? dataAudio = null,
  }) {
    return _then(_$SettingsScreenStateReady(
      pages: null == pages
          ? _value._pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<SettingsPageType>,
      initialPageIndex: null == initialPageIndex
          ? _value.initialPageIndex
          : initialPageIndex // ignore: cast_nullable_to_non_nullable
              as int,
      dataGeneral: null == dataGeneral
          ? _value.dataGeneral
          : dataGeneral // ignore: cast_nullable_to_non_nullable
              as SettingsDataGeneral,
      dataText: null == dataText
          ? _value.dataText
          : dataText // ignore: cast_nullable_to_non_nullable
              as SettingsDataText,
      dataAudio: null == dataAudio
          ? _value.dataAudio
          : dataAudio // ignore: cast_nullable_to_non_nullable
              as SettingsDataAudio,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $SettingsDataGeneralCopyWith<$Res> get dataGeneral {
    return $SettingsDataGeneralCopyWith<$Res>(_value.dataGeneral, (value) {
      return _then(_value.copyWith(dataGeneral: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SettingsDataTextCopyWith<$Res> get dataText {
    return $SettingsDataTextCopyWith<$Res>(_value.dataText, (value) {
      return _then(_value.copyWith(dataText: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SettingsDataAudioCopyWith<$Res> get dataAudio {
    return $SettingsDataAudioCopyWith<$Res>(_value.dataAudio, (value) {
      return _then(_value.copyWith(dataAudio: value));
    });
  }
}

/// @nodoc

class _$SettingsScreenStateReady implements SettingsScreenStateReady {
  _$SettingsScreenStateReady(
      {required final List<SettingsPageType> pages,
      required this.initialPageIndex,
      required this.dataGeneral,
      required this.dataText,
      required this.dataAudio})
      : _pages = pages;

  final List<SettingsPageType> _pages;
  @override
  List<SettingsPageType> get pages {
    if (_pages is EqualUnmodifiableListView) return _pages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pages);
  }

  @override
  final int initialPageIndex;
  @override
  final SettingsDataGeneral dataGeneral;
  @override
  final SettingsDataText dataText;
  @override
  final SettingsDataAudio dataAudio;

  @override
  String toString() {
    return 'SettingsScreenState.ready(pages: $pages, initialPageIndex: $initialPageIndex, dataGeneral: $dataGeneral, dataText: $dataText, dataAudio: $dataAudio)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SettingsScreenStateReady &&
            const DeepCollectionEquality().equals(other._pages, _pages) &&
            (identical(other.initialPageIndex, initialPageIndex) ||
                other.initialPageIndex == initialPageIndex) &&
            (identical(other.dataGeneral, dataGeneral) ||
                other.dataGeneral == dataGeneral) &&
            (identical(other.dataText, dataText) ||
                other.dataText == dataText) &&
            (identical(other.dataAudio, dataAudio) ||
                other.dataAudio == dataAudio));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_pages),
      initialPageIndex,
      dataGeneral,
      dataText,
      dataAudio);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SettingsScreenStateReadyCopyWith<_$SettingsScreenStateReady>
      get copyWith =>
          __$$SettingsScreenStateReadyCopyWithImpl<_$SettingsScreenStateReady>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)
        ready,
  }) {
    return ready(pages, initialPageIndex, dataGeneral, dataText, dataAudio);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)?
        ready,
  }) {
    return ready?.call(
        pages, initialPageIndex, dataGeneral, dataText, dataAudio);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(
            List<SettingsPageType> pages,
            int initialPageIndex,
            SettingsDataGeneral dataGeneral,
            SettingsDataText dataText,
            SettingsDataAudio dataAudio)?
        ready,
    required TResult orElse(),
  }) {
    if (ready != null) {
      return ready(pages, initialPageIndex, dataGeneral, dataText, dataAudio);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(SettingsScreenStateReady value) ready,
  }) {
    return ready(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(SettingsScreenStateReady value)? ready,
  }) {
    return ready?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(SettingsScreenStateReady value)? ready,
    required TResult orElse(),
  }) {
    if (ready != null) {
      return ready(this);
    }
    return orElse();
  }
}

abstract class SettingsScreenStateReady implements SettingsScreenState {
  factory SettingsScreenStateReady(
      {required final List<SettingsPageType> pages,
      required final int initialPageIndex,
      required final SettingsDataGeneral dataGeneral,
      required final SettingsDataText dataText,
      required final SettingsDataAudio dataAudio}) = _$SettingsScreenStateReady;

  List<SettingsPageType> get pages;
  int get initialPageIndex;
  SettingsDataGeneral get dataGeneral;
  SettingsDataText get dataText;
  SettingsDataAudio get dataAudio;
  @JsonKey(ignore: true)
  _$$SettingsScreenStateReadyCopyWith<_$SettingsScreenStateReady>
      get copyWith => throw _privateConstructorUsedError;
}
